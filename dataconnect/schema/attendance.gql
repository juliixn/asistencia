
type AttendanceRecord @table(key: "attendanceRecordId") {
    attendanceRecordId: String! @db(default: "id.uuidV4()")
    employeeId: String!
    date: String!
    shift: String!
    status: String!
    locationId: String
    photoEvidence: String
    notes: String
    employee: Employee @foreignKey(field: "employeeId", references: "employeeId")
    location: WorkLocation @foreignKey(field: "locationId", references: "workLocationId")
}

query listAttendanceRecords(
    employeeId: String,
    startDate: String,
    endDate: String
): [AttendanceRecord] @auth(level: ADMIN)

mutation createOrUpdateAttendanceRecord(
    # We need a unique key for the combination of employee, date, and shift
    # to decide whether to create a new record or update an existing one.
    # We will handle this logic in the application code.
    attendanceRecordId: String, # Provide to update, null to create
    employeeId: String!,
    date: String!,
    shift: String!,
    status: String!,
    locationId: String,
    photoEvidence: String,
    notes: String
): AttendanceRecord! @auth(level: ADMIN)
